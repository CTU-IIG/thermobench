var documenterSearchIndex = {"docs":
[{"location":"#Thermobench.jl-1","page":"Thermobench.jl","title":"Thermobench.jl","text":"","category":"section"},{"location":"#","page":"Thermobench.jl","title":"Thermobench.jl","text":"DocTestSetup = :(using DataFrames; using Thermobench)","category":"page"},{"location":"#","page":"Thermobench.jl","title":"Thermobench.jl","text":"Julia module for working with thermobench-produced CSV files.","category":"page"},{"location":"#Installation-1","page":"Thermobench.jl","title":"Installation","text":"","category":"section"},{"location":"#","page":"Thermobench.jl","title":"Thermobench.jl","text":"Run julia and type:","category":"page"},{"location":"#","page":"Thermobench.jl","title":"Thermobench.jl","text":"]develop /path/to/thermobench/julia","category":"page"},{"location":"#Reference-1","page":"Thermobench.jl","title":"Reference","text":"","category":"section"},{"location":"#","page":"Thermobench.jl","title":"Thermobench.jl","text":"Modules = [Thermobench]","category":"page"},{"location":"#Thermobench.fit-Tuple{Array{Float64,1},Any}","page":"Thermobench.jl","title":"Thermobench.fit","text":"fit(\n    time_s::Vector{Float64},\n    data;\n    order::Int64 = 2,\n    p0 = nothing,\n    tau_bounds = [(1, 60*60)],\n    k_bounds = [(-120, 120)],\n    T_bounds = (0, 120),\n    use_cmpfit::Bool = false,\n )\n\nFit a thermal model to time series.\n\nIf use_cmpfit is true, use CMPFit.jl package rather than LsqFit.jl. LsqFit doesn't work well in constrained fit.\n\nYou can limit the values of fitted parameters with *_bounds parameters. Each bound is a tuple of lower and upper limit. T_bounds limits the T∞ parameter. tau_bounds and k_bounds limit the coefficients of exponential functions ke^-tτ. If you specify less tuples than the order of the model, the last limit will be repeated.\n\nExample\n\ndf = read(\"test.csv\")\nf = fit(df.time_s, df.CPU_0_temp_°C)\ncoef(f)\nThermobench.printfit(f)\n\n\n\n\n\n","category":"method"},{"location":"#Thermobench.interpolate!-Tuple{DataFrames.AbstractDataFrame}","page":"Thermobench.jl","title":"Thermobench.interpolate!","text":"interpolate!(df::AbstractDataFrame)\n\nIn-place version of interpolate.\n\n\n\n\n\n","category":"method"},{"location":"#Thermobench.interpolate-Tuple{DataFrames.AbstractDataFrame}","page":"Thermobench.jl","title":"Thermobench.interpolate","text":"interpolate!(df::AbstractDataFrame)\n\nReplace missing values with results of linear interpolation performed against the first column (time).\n\njulia> x = DataFrame(t=[0.0, 1, 2, 3, 1000, 1001], v=[0.0, missing, missing, missing, 1000.0, missing])\n6×2 DataFrame\n│ Row │ t       │ v        │\n│     │ Float64 │ Float64? │\n├─────┼─────────┼──────────┤\n│ 1   │ 0.0     │ 0.0      │\n│ 2   │ 1.0     │ missing  │\n│ 3   │ 2.0     │ missing  │\n│ 4   │ 3.0     │ missing  │\n│ 5   │ 1000.0  │ 1000.0   │\n│ 6   │ 1001.0  │ missing  │\n\njulia> interpolate(x)\n6×2 DataFrame\n│ Row │ t       │ v        │\n│     │ Float64 │ Float64? │\n├─────┼─────────┼──────────┤\n│ 1   │ 0.0     │ 0.0      │\n│ 2   │ 1.0     │ 1.0      │\n│ 3   │ 2.0     │ 2.0      │\n│ 4   │ 3.0     │ 3.0      │\n│ 5   │ 1000.0  │ 1000.0   │\n│ 6   │ 1001.0  │ missing  │\n\n\n\n\n\n\n","category":"method"},{"location":"#Thermobench.multi_fit","page":"Thermobench.jl","title":"Thermobench.multi_fit","text":"multi_fit(sources, columns = :CPU_0_temp_°C;\n          timecol = :time_s,\n          use_measurements = false,\n          order::Int64 = 2,\n          subtract = nothing,\n          kwargs...)::MultiFit\n\nCall fit() for all sources and report the results (coefficients etc.) in DataFrame. When use_measurements is true, report coefficients with their confidence intervals as Measurement objects.\n\nsubtract specifies the column (symbol), which is subtracted from data after interpolating its values with interpolate. This intended for subtraction of ambient temperature.\n\njulia> multi_fit(\"test.csv\", [:CPU_0_temp_°C :CPU_1_temp_°C])\nPrefix: test.csv\n2×8 DataFrame\n│ Row │ name   │ column        │ mse       │ Tinf    │ k1       │ tau1    │ k2       │ tau2    │\n│     │ String │ Symbol        │ Float64   │ Float64 │ Float64  │ Float64 │ Float64  │ Float64 │\n├─────┼────────┼───────────────┼───────────┼─────────┼──────────┼─────────┼──────────┼─────────┤\n│ 1   │        │ CPU_0_temp_°C │ 0.023865  │ 53.0003 │ -8.1627  │ 59.366  │ -13.1247 │ 317.63  │\n│ 2   │        │ CPU_1_temp_°C │ 0.0208397 │ 54.0527 │ -7.17072 │ 51.1449 │ -14.3006 │ 277.687 │\n\n\n\n\n\n","category":"function"},{"location":"#Thermobench.plot_fit","page":"Thermobench.jl","title":"Thermobench.plot_fit","text":"plot_fit(sources, columns = :CPU_0_temp_°C;\n         timecol = :time_s,\n         kwargs...)\n\nCall fit for all sources and columns and produce a graph using gnuplot.\n\nsources can be a file name (String) or a DataFrame or an array of these.\n\ntimecol is the columns with time of measurement.\n\nSetting plotexp to true causes the individual fitted exponentials to be plotted in addition to the compete fitted function.\n\nOther kwargs are passed to fit.\n\nExample\n\nplot_fit(\n    [\"file$i.csv\" for i in 1:3],\n    [:CPU_0_temp_°C, :GPU_0_temp_°C],\n    order = 2\n)\n\njulia> plot_fit(\"test.csv\", [:CPU_0_temp_°C :CPU_1_temp_°C])\nrss(fit) = 16.824847736915736\nrss(fit) = 14.692012083459852\nLsqFit.LsqFitResult{Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,1}}([54.05270193617456, -14.300579425822987, 277.6871572171704, -7.170707187492722, 51.1449427363974], [0.4814153228588438, 0.48210393166134935, -0.02827469472873645, 0.1590733915246858, -0.25639810428151577, -0.2745094012142104, -0.29552833686121005, -0.3190430919820457, 0.054645980053877, -0.1740621999878087  …  -0.10112334959897851, -0.09697970488952024, -0.09284269210126439, 0.11127121083011815, 0.11537443369089573, 0.11946698541304812, -0.0764592578095602, -0.07240014726207278, 0.1316443697488907, -0.26432565427360544], [1.0 1.0 … 1.0 -0.0; 1.0 0.9999870640586986 … 0.9999297674088051 -9.84651920490284e-6; … ; 1.0 0.07839196015996269 … 9.920656343511463e-7 -1.9227241374458278e-6; 1.0 0.07811016470837553 … 9.728568932023543e-7 -1.8881625354797446e-6], true, Float64[])\n\n\n\n\n\n","category":"function"},{"location":"#Thermobench.printfit-Tuple{Any}","page":"Thermobench.jl","title":"Thermobench.printfit","text":"printfit(fit; minutes = false)\n\nReturn the fitted function as Gnuplot enhanced string. Time constants (τᵢ) are sorted from smallest to largest.\n\n\n\n\n\n","category":"method"},{"location":"#Thermobench.@symarray-Tuple","page":"Thermobench.jl","title":"Thermobench.@symarray","text":"Construct array of symbols from arguments.\n\nUseful for constructing column names, e.g.,\n\n@symarray Cortex_A57_temp_°C Denver2_temp_°C\n\n\n\n\n\n","category":"macro"},{"location":"#Thermobench.normalize_units!-Tuple{DataFrames.AbstractDataFrame}","page":"Thermobench.jl","title":"Thermobench.normalize_units!","text":"Normalize units to seconds and °C\n\n\n\n\n\n","category":"method"},{"location":"#Thermobench.read-Tuple{Any}","page":"Thermobench.jl","title":"Thermobench.read","text":"read(source; normalizeunits=true)\n\nRead thermobech CSV file, optionally normalizing units and return it as DataFrame\"\n\n\n\n\n\n","category":"method"},{"location":"#Thermobench.thermocam_correct!-Tuple{DataFrames.AbstractDataFrame}","page":"Thermobench.jl","title":"Thermobench.thermocam_correct!","text":"thermocam_correct!(df::AbstractDataFrame)\n\nEstimate correction for thermocamera temperatures and apply it. Return the correction coefficients.\n\nCorrection is calculated from CPU_0_temp_°C and cam_cpu columns. This and the names of modified columns are currently hard coded.\n\n\n\n\n\n","category":"method"},{"location":"#","page":"Thermobench.jl","title":"Thermobench.jl","text":"DocTestSetup = nothing","category":"page"}]
}
